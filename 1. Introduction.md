Computer graphics라는 용어는 컴퓨터를 이용해 이미지를 생성하고 조작하는 모든 용도를 설명합니다.

이 책은 사실적인 시각적 효과, 정보 그래픽, 기술적 삽화 또는 컴퓨터 생성 장면과 같은 다양한 유형의 이미지를 만드는 데 사용되는 알고리즘과 수학적 도구를 소개합니다.

실제로 컴퓨터 그래픽스를 구현하려면 특정 하드웨어, 파일 형식 및 그래픽 API(1.3절 참조)에 대해 알고 있어야 합니다. 컴퓨터 그래픽스는 빠르게 발전하는 분야이므로, 이 책에서는 특정 하드웨어나 API에 의존하지 않도록 최선을 다했습니다. 독자들은 관련 문서를 참고하여 자신의 소프트웨어 및 하드웨어 환경에 맞추어 내용을 보완할 것이 권장됩니다.

이 장에서는 기본적인 용어와 컴퓨터 그래픽스와 관련된 역사적 배경을 정의합니다.

<aside>
💡 API : Application Program Interface

</aside>

# 1.1 Graphics Areas

그래픽스 범주를 지정하는 것은 위험하지만 아래 3개 범주는 너무나도 대표적입니다.

- Modeling

컴퓨터에 저장할 수 있는 모양과 외관의 특성에 대한 수학적 사양을 다룹니다. 예를 들어, 커피 머그잔은 일련의 정돈된 3D 점으로 설명될 수 있으며, 반사 모델은 머그잔이 빛과 어떻게 상호작용하는지 설명합니다.

- Rendering

예술에서 차용한 용어로, 3D 컴퓨터 모델에서 음영, 질감 등의 이미지를 만드는 것을 말합니다.

- Animation

이미지 시퀀스를 통해 마치 움직이는 것처럼 표현하는 기술입니다. Modeling과 rendering 기술이 사용되지만 시간에 따른 움직임이 핵심 문제입니다. 이는 일반적으로 modeling과 rendering에서는 다루지 않습니다.

이외에도 다른 그래픽스 범주가 있지만 이들이 핵심 그래픽스 영역인지 여부는 의견 차이가 있습니다.

- User Interaction

마우스, 태블릿, 애플리케이션, 사용자 피드백, 감각 피드백 같은 입력장치와의 상호작용을 다룹니다.

- Virtual reality

사용자를 3D 가상세계에 몰입시키기 위해 다양한 시도를 합니다. 이 영역은 고급 3D 그래픽과 디스플레이 기술을 필요로 하기에 연관이 있습니다.

- Visualization

시각화는 사용자가 시각적 디스플레이를 통해 복잡한 정보를 제공할 수 있습니다.

- Image processing

2D 이미지에 대한 조작을 다루며 그래픽스와 비전 분야에 모두 사용됩니다.

- 3D scanning

range-finding technology를 이용해 측정된 3D 모델을 생성합니다. 모델 생성 처리를 위해 그래픽스 알고리즘이 필요한 경우가 많습니다.

- Computional photography

Computer graphics, computer vision, image processing을 이용해 새로운 방식으로 대상, 장면, 환경을 사진으로 포착할 수 있게 하는 기술입니다.

# 1.2 Major Applications

거의 모든 분야에서 computer graphics가 사용되고 있으나, 주요 사용 분야는 다음과 같습니다.

- Video games
- Cartoons
- Visual Effects
- Animated films
- CAD/CAM
- Simulation
- Medical imaging
- Information visualization

# 1.3 Grahpics APIs

Graphics library를 사용하는 핵심 부분은 graphics API와 관련되어있습니다.

API는 특정 기능을 수핵하기 위한 기능들의 표준 집합입니다. Graphics API는 이미지 그리기, 화면에 3D 표면 렌더링 등과 같은 기능을 수행하기 위한 집합입니다.

모든 Graphics program은 두가지 관련 API를 사용할 수 있어야 합니다. 출력을 위한 API와 사용자 인터페이스를 위한 API입니다. 현재 해당 API들에는 크게 두가지 주요 패러다임이 있습니다.

1. Java

Java에서 graphics와 user-interface 툴킷이 통합되고 이식 가능한 패키지 형태로 제공됩니다.

1. OpenGL, Direct3D

그래픽스 명령어가 C++ 언어로 연결된 소프트웨어 라이브러리의 일부이며, user-interface는 시스템마다 다른 독립적인 개체입니다.

어떤 API를 선택해도 사용되는 그래픽스 이론은 비슷합니다.

# 1.4 Graphics Pipeline

오늘날 모든 데스크탑 컴퓨터에는 강력한 3D Graphics pipeline이 있습니다.

3D Graphics pipeline은 3D primitive를 효율적으로 그리기 위한 소프트웨어/하드웨어 하위 시스템입니다.

일반적으로 이러한 시스템은 3D 삼각형을 처리하고 3D vertex 위치를 2d screen 좌표를 매핑하고 음영 처리를 통해 현실적으로 보이도록 합니다.

삼각형의 앞뒤를 적절한 순서로 그리는 것이 한 때 중요한 연구 주제였지만 현재 z-buffer를 이용해 거의 항상 해결되고 있습니다.

Graphics pipeline에서 사용되는 기하학적 조작은 4D coordinate를 통해 해결되었다.

# 1.5 Numerical Issue

IEEE 부동소수점 표준을 모든 최신 컴퓨터가 지키고 있어 프로그래밍 시 수치 조건을 처리할 수 있는 편리한 가정을 내릴 수 있습니다.

1. Infinity ($\infty$)

다른 모든 유효한 숫자보다 큰 유효한 숫자

1. Minus infinity (-$\infty$)

다른 모든 유효한 숫자보다 작은 유효한 숫자

1. Not a Number (NaN)

0을 0으로 나눈 것과 같이 정의되지 않는 결과를 가진 연산에서 발생하는 유효하지 않은 숫자

IEEE 부동소수점 설계자들은 프로그래머들에게 매우 편리한 몇가지 결정을 내렸습니다. 위 세가지 특수한 값과 관련되어 있습니다.

$$
+a/(+\infty)=+0
\\
-a/(+\infty)=-0
\\
-a/(-\infty)=+0
$$

$$
\infty+\infty=\infty
\\
\infty-\infty=NaN
\\
\infty \times \infty=\infty
\\
\infty / \infty=\infty
\\
\infty/a=\infty
\\
\infty/0=\infty
\\
0/0=NaN
$$

무한 값을 포함하는 Boolean 표현식의 규칙은 다음과 같습니다.

1. 모든 유한한 유효 숫자는 +$\infty$보다 작습니다.
2. 모든 유한한 유효 숫자는 -$\infty$보다 큽니다.
3. -$\infty$는  +$\infty$보다 작습니다.

NaN 값을 포함하는 표현식의 규칙은 다음과 같습니다.

1. NaN을 포함하는 모든 산술 표현식의 결과는 NaN입니다.
2. NaN을 포함하는 모든 Boolean 표현식은 false입니다.

IEEE 부동소수점의 유용한 측면 중 하나로 0으로 나누기를 처리하는 방식입니다.

$$
+a/+0=+\infty
\\
-a/+0=-\infty
$$

이 규칙을 활용하면 많은 수치 계산이 훨씬 간단해집니다. 아래 표현식을 예로 들어봅시다.

$$
a={1\over{{1\over {b}} + {1\over {c}}}}
$$

이러한 표현식은 레지스터나 렌즈 관련 계산에서 발생합니다. 만약 0으로 나누기가 프로그램 충돌을 일으킨다면 0인지 아닌지 확인하기 위한 if문이 필요해집니다. IEEE 부동소수점을 사용하면 b나 c가 0인 경우 a의 값은 0이 됩니다.

또다른 기법은 NaN의 Boolean 속성을 활용하는겁니다.

```cpp
a=f(x)
if(a > 0) then
	do something
```

여기서 함수 f는 NaN과 같이 이상한 값을 반환할 수 있습니다. a가 NaN이면 해당 Boolean 표현식은 무조건 false가 됩니다.

이런식으로 IEEE 부동소수점 특성을 활용해 프로그램을 더 작고 효율적으로 만들 수 있습니다.

# 1.6 Efficiency

코드를 빠르게 만드는 합리적인 접근 방식은 다음 순서로 진행하며 필요한 단계만 수행하는 것입니다.

1. 가능한 가장 직관적인 방식으로 코드를 작성합니다. 중간 결과는 저장하지 않고 필요할 때마다 즉시 계산합니다.
2. 최적화 모드로 컴파일합니다.
3. 프로파일링 도구를 통해 병목 지점을 찾습니다.
4. 데이터 구조를 검토해 지역성을 개선할 방법을 찾습니다. 가능하다면 데이터 단위 크기를 대상 아키텍처의 캐시/페이지 크기와 일치시킵니다.
5. 프로파일링 결과 숫자 계산에서 병목 현상이 드러나면 컴파일러가 생성한 어셈블리 코드를 검토해 누락된 효율성을 찾습니다. 문제를 해결하기 위해 소스코드를 다시 작성합니다.

이 중 가장 중요한 것은 첫번째 입니다. 대부분의 **최적화** 는 코드를 읽기 어렵게 만듭니다. 또한 초기 코드를 최적화하는데 시간을 쓰는 것보다 버그를 수정하거나 기능을 추가하는 데 시간을 쓰는 것이 보통 더 좋습니다.

정수를 실수 대신 사용하는 것과 같은 고전적인 트릭은 오늘날 더 이상 속도를 높이지 않을 수 있습니다.

모든 상황에서 특정 기계와 컴파일러에 대한 최적화의 장점을 확신하려면 프로파일링이 필요합니다. 

# 1.7 Designing and Coding Graphics Programs

그래픽스 프로그래밍을 할 때 유용한 몇가지 전략이 있습니다.

## 1.7.1 클래스 설계

기하학적 객체 및 RGB와 같은 그래픽 개체를 위한 깔끔하고 효율적인 클래스를 가지는 것이 중요합니다.

보편적인 설계 질문 중 하나는 위치와 변위를 별도의 클래스로 만들어야 하는지 여부입니다. 이 둘은 서로 다른 연산을 가지기 때문입니다.

ex) 위치에 1/2를 곱하는건 기하학적으로 의미가 없지만 변위의 1/2는 의미가 있습니다.

네, 맞습니다. 임의의 위치 (x, y)에 1/2를 곱하면 결과는 (x/2, y/2)가 되지만, 이는 단지 다른 절대적인 위치를 나타낼 뿐입니다.

기하학적으로 의미가 없다는 것은, 위치에 스칼라 값을 곱하는 연산이 위치의 본질적인 특성을 유지하지 않기 때문입니다. 위치는 절대적인 좌표를 나타내며, 그 자체로 특정 지점을 의미합니다. 따라서 위치에 스칼라 값을 곱해서 새로운 위치를 생성하는 것은, 단지 다른 지점을 나타내는 것일 뿐, 특별한 기하학적 의미를 부여하는 것이 아닙니다.

반면에, 변위는 상대적인 양과 방향을 나타내기 때문에, 변위에 스칼라 값을 곱하는 것은 그 크기와 방향을 변경하는 명확한 기하학적 의미를 가집니다. 예를 들어, 변위 벡터 (dx, dy)에 1/2를 곱하면 (dx/2, dy/2)가 되어, 원래 변위의 절반 크기를 가지는 변위를 생성합니다. 이는 이동 거리와 방향이 줄어드는 것을 의미하므로, 기하학적으로 타당한 연산입니다.

따라서, 위치에 스칼라 값을 곱하는 것은 단지 다른 절대적인 위치를 나타내는 것이며, 기하학적 의미가 불명확합니다.

- 위치는 객체가 공간 내에서 차지하는 특정 지점을 나타내며, 보통 좌표로 표현됩니다.
- 변위는 객체가 한 위치에서 다른 위치로 이동하는 양과 방향을 나타내며, 벡터로 표현됩니다.
- 위치는 절대적인 값을 가지지만, 변위는 상대적인 변화를 나타냅니다.

<aside>
💡 작성자 입장은 분리하는게 코드 가독성을 높이고 컴파일러가 몇가지 버그를 잡게 해준단다

</aside>

작성해야 할 기본 클래스는 다음과 같습니다.

- Vector2 : x와 y 구성 요소를 저장하는 2D 벡터 클래스입니다. 인덱싱 연산자를 잘 지원할 수 있도록 길이 2 배열에 이 구성 요소들을 저장해야 합니다. 또한 벡터 덧셈, 벡터 뺄셈, 내적, 외적, 스칼라 곱셈 및 스칼라 나눗셈에 대한 연산도 포함해야 합니다.
- Vector3 : Vector2와 유사한데 x y z 구성요소를 가집니다.
- HVector : 4가지 구성 요소를 가지는 [동차 벡터](https://handhp1.tistory.com/5)
- RGB : 세 가지 구성 요소를 저장하는 RGB 색상 클래스입니다. RGB 덧셈, RGB 뺄셈, RGB 곱셈, 스칼라 곱셈 및 스칼라 나눗셈에 대한 연산도 포함해야 합니다.
- Transform : 변환을 위한 4x4 행렬입니다. 위치, 방향 및 표면 법선 벡터에 적용할 행렬 곱셈 및 멤버 함수를 포함해야 합니다.
- Image : 출력 연산이 있는 RGB 픽셀의 2D 배열입니다.

## 1.7.2 float vs double

현대 아키텍처는 메모리 사용을 줄이고 일관된 메모리 액세스를 유지하는 것이 효율성의 열쇠라고 제안합니다. 이는 single-precision data(float)를 사용하는 것을 제안하지만 수치 문제를 피하기 위해서는 double-precision data(double)를 사용하는 것이 좋습니다.

<aside>
💡 기하학적 계산에는 double, 색상 계산에는 float를 사용할 것을 제안합니다. 삼각형 메쉬와 같이 많은 메모리를 차지하는 데이터의 경우, 데이터를 float로 저장하되, 멤버 함수를 통해 데이터에 접근할 때는 double로 변환할 것을 제안합니다.

</aside>

<aside>
💡 모든 계산을 float로 수행하다가 특정 부분에서 double 정밀도가 필요하다는 증거를 찾으면 그때 double을 사용하는 것을 권장합니다.

</aside>
